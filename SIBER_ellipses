###########################################################################
##################  Create the siber object for Ellipses  #################
###########################################################################


CN_object <- createSiberObject(CN)

CN_layer <- createSiberObject(CNLayer)
CN_core <- createSiberObject(CNCore)

# Create lists of plotting arguments to be passed onwards to each 
# of the three plotting functions.
community.hulls.args <- list(col = 1, lty = 1, lwd = 1)
group.ellipses.args  <- list(n = 100, p.interval = 0.95, 
                             lty = 1, lwd = 2)
group.hull.args      <- list(lty = 2, col = "grey20")


##################################################################################
################# Bayesian ellipse overlap #######################################
##################################################################################
# options for running jags
parms <- list()
parms$n.iter <- 2 * 10^4   # number of iterations to run the model for
parms$n.burnin <- 1 * 10^3 # discard the first set of values
parms$n.thin <- 10     # thin the posterior by this many
parms$n.chains <- 2        # run this many chains

# define the priors
priors <- list()
priors$R <- 1 * diag(2)
priors$k <- 2
priors$tau.mu <- 1.0E-3

ellipses.posteriorCNlayer <- siberMVN(CN_layer, parms, priors)
ellipses.posteriorCNcore <- siberMVN(CN_core, parms, priors)

#Define ellipses
ellipse1 <- "1.1" # So in this example: community 1, group 1
ellipse2 <- "1.2" # Ellipse two is similarly defined: community 1, group2
ellipse3 <- "1.3" # So in this example: community 1, group 3

###Group 1 = Blue Dog, Group 2 = Clear Lake, Group 3 = RAS

# and the corresponding Bayesian estimates for the overlap between the 
# 95% ellipses is given by:
bayes95.overlap1.2 <- bayesianOverlap(ellipse1, ellipse2, ellipses.posteriorCNcore,
                                   draws = 1000, p.interval = 0.95, n = 100)

bayes95.overlap1.3 <- bayesianOverlap(ellipse1, ellipse3, ellipses.posteriorCNcore,
                                      draws = 1000, p.interval = 0.95, n = 100)

bayes95.overlap2.3 <- bayesianOverlap(ellipse2, ellipse3, ellipses.posteriorCNcore,
                                      draws = 1000, p.interval = 0.95, n = 100)
# a histogram of the overlap
#hist(bayes95.overlap1.3[,3], 10)

# and as above, you can express this a proportion of the non-overlapping area of 
# the two ellipses, would be
bayes.prop.95.over1.2 <- (bayes95.overlap1.2[,3] / (bayes95.overlap1.2[,2] + 
                                                bayes95.overlap1.2[,1] -
                                                bayes95.overlap1.2[,3]))

bayes.prop.95.over1.3 <- (bayes95.overlap1.3[,3] / (bayes95.overlap1.3[,2] + 
                                                      bayes95.overlap1.3[,1] -
                                                      bayes95.overlap1.3[,3]))

bayes.prop.95.over2.3 <- (bayes95.overlap1.2[,3] / (bayes95.overlap2.3[,2] + 
                                                      bayes95.overlap2.3[,1] -
                                                      bayes95.overlap2.3[,3]))
tidybayes::mean_qi(bayes.prop.95.over1.2)
tidybayes::mean_qi(bayes.prop.95.over1.3)
tidybayes::mean_qi(bayes.prop.95.over2.3)

############################################################################
#################  Plot Bayesian Ellipses  #################################
############################################################################
# how many of the posterior draws do you want?
n.posts <- 10
# decide how big an ellipse you want to draw
p.ell <- 0.95

# a list to store the results
all_ellipses <- list()

# loop over groups
for (i in 1:length(ellipses.posteriorCNcore)){
  
  # a dummy variable to build in the loop
  ell <- NULL
  post.id <- NULL
  for ( j in 1:n.posts){
    # covariance matrix
    Sigma  <- matrix(ellipses.posteriorCNcore[[i]][j,1:4], 2, 2)
    # mean
    mu     <- ellipses.posteriorCNcore[[i]][j,5:6]
    # ellipse points
    out <- ellipse::ellipse(Sigma, centre = mu , level = p.ell)
    ell <- rbind(ell, out)
    post.id <- c(post.id, rep(j, nrow(out)))
}
  ell <- as.data.frame(ell)
  ell$rep <- post.id
  all_ellipses[[i]] <- ell
}

ellipse_df <- bind_rows(all_ellipses, .id = "id")

# now we need the group and community names
# extract them from the ellipses.posterior list
group_comm_names <- names(ellipses.posteriorCNcore)[as.numeric(ellipse_df$id)]

# split them and conver to a matrix, NB byrow = T
split_group_comm <- matrix(unlist(strsplit(group_comm_names, "[.]")),
                           nrow(ellipse_df), 2, byrow = TRUE)

ellipse_df$community <- split_group_comm[,1]
ellipse_df$group     <- split_group_comm[,2]

ellipse_df <- dplyr::rename(ellipse_df, iso1 = x, iso2 = y) %>% 
  mutate(Location = case_when(group=="1"~"Pond", 
                              group=="2"~"Lake", 
                              group=="3"~"RAS")) 

#plot
CNcore2<-CNCore %>% 
  mutate(Location = case_when(group=="1"~"Pond", 
                              group=="2"~"Lake", 
                              group=="3"~"RAS"))   
plotCNcore <-  ggplot(CNcore2,aes(iso1, iso2)) +
  geom_point(aes(color = factor(Location), shape=factor(Location), fill= after_scale(alpha(color, 0.2))), 
             size = 0.8, stroke=0.4)+
  geom_polygon(data = ellipse_df,fill = NA, alpha = 0.2, linewidth=0.2,
               mapping = aes(iso1, iso2, 
                             group = interaction(rep, factor(Location)),linetype = as.factor(Location),
                             color = factor(Location),
                             fill = NULL))+
  ylab("   ")+
  xlab(expression(paste(delta^{13}, "C"," (\u2030)")))+
  xlab(NULL)+
  scale_color_manual(values=c("orange2", "black", "blue"), name=NULL, labels=c("Lake", "Pond", "RAS"))+
  scale_fill_manual(values=c("orange2", "black", "blue"),name=NULL,labels=c("Lake", "Pond", "RAS"))+
  scale_x_continuous(limits=c(-30,-14))+
  scale_y_continuous(limits=c(0,30), breaks=seq(0,30,5))+
  scale_shape_manual(values=c(23,22,21),name=NULL,labels=c("Lake", "Pond", "RAS"))+
  scale_linetype_manual(values=c(1,2,4), name=NULL, labels=c("Lake", "Pond", "RAS"))+
  geom_text(aes(label="A",x=-15, y=30),fontface = "bold", vjust=2, hjust=1)+
  theme_classic()+
  theme(axis.text = element_text(size=8), 
        axis.title = element_text(size=10),
        strip.background = element_blank(),
        strip.text = element_text(size=8), 
        legend.position = "top", 
        plot.margin = unit(c(0.1,0.1,0.1,0.16), units="in")); plotCNcore


# how many of the posterior draws do you want?
n.posts <- 10
# decide how big an ellipse you want to draw
p.ell <- 0.95

# a list to store the results
all_ellipses2 <- list()

# loop over groups
for (i in 1:length(ellipses.posteriorCNlayer)){
  
  # a dummy variable to build in the loop
  ell <- NULL
  post.id <- NULL
  for ( j in 1:n.posts){
    # covariance matrix
    Sigma  <- matrix(ellipses.posteriorCNlayer[[i]][j,1:4], 2, 2)
    # mean
    mu     <- ellipses.posteriorCNlayer[[i]][j,5:6]
    # ellipse points
    out <- ellipse::ellipse(Sigma, centre = mu , level = p.ell)
    ell <- rbind(ell, out)
    post.id <- c(post.id, rep(j, nrow(out)))
  }
  ell <- as.data.frame(ell)
  ell$rep <- post.id
  all_ellipses2[[i]] <- ell
}

ellipse_df2 <- bind_rows(all_ellipses2, .id = "id")

# now we need the group and community names
# extract them from the ellipses.posterior list
group_comm_names <- names(ellipses.posteriorCNlayer)[as.numeric(ellipse_df$id)]

# split them and conver to a matrix, NB byrow = T
split_group_comm <- matrix(unlist(strsplit(group_comm_names, "[.]")),
                           nrow(ellipse_df2), 2, byrow = TRUE)

ellipse_df2$community <- split_group_comm[,1]
ellipse_df2$group     <- split_group_comm[,2]

ellipse_df2 <- dplyr::rename(ellipse_df2, iso1 = x, iso2 = y) %>% 
  mutate(Location = case_when(group=="1"~"Pond", 
                              group=="2"~"Lake", 
                              group=="3"~"RAS")) 

#plot
CNlayer2<- CNLayer %>% 
  mutate(Location = case_when(group=="1"~"Pond", 
                              group=="2"~"Lake", 
                              group=="3"~"RAS")) 
plotCNlayer<-  ggplot(CNlayer2,aes(iso1, iso2)) +
  geom_point(aes(color = factor(Location), shape=factor(Location), fill= after_scale(alpha(color, 0.2))), 
             size = 0.8, stroke=0.4)+
  geom_polygon(data = ellipse_df2,fill = NA, alpha = 0.2, linewidth=0.2,
               mapping = aes(iso1, iso2, 
                             group = interaction(rep, factor(Location)),linetype = as.factor(Location),
                             color = factor(Location),
                             fill = NULL))+
  ylab(expression(paste(delta^{15}, "N"," (\u2030)")))+
  xlab(expression(paste(delta^{13}, "C"," (\u2030)")))+
  scale_color_manual(values=c("orange2", "black",  "blue"), name=NULL, labels=c("Pond", "Lake", "RAS"))+
  scale_fill_manual(values=c("orange2", "black", "blue"),name=NULL,labels=c("Pond", "Lake", "RAS"))+
  xlab(expression(paste(delta^{13}, "C"," (\u2030)")))+
  scale_x_continuous(limits=c(-30,-14))+
  scale_y_continuous(limits=c(0,30), breaks=seq(0,30,5))+
  scale_shape_manual(values=c(23,22,21),name=NULL,labels=c("Pond", "Lake", "RAS"))+
  scale_linetype_manual(values=c(1,2,4), name=NULL, labels=c("Pond", "Lake", "RAS"))+
  geom_text(aes(label="B",x=-15, y=30),fontface = "bold", vjust=2, hjust=1)+
  theme_classic()+
  coord_cartesian(clip = F)+
  theme(axis.text = element_text(size=8), 
        axis.title = element_text(size=10),
        axis.title.y = element_text(hjust = 1.3),
        strip.background = element_blank(),
        strip.text = element_text(size=8), 
        legend.position = "none", 
        plot.margin = unit(c(0.1,0.1,0.1,0.16), units="in")); plotCNlayer

CN_comb<-cowplot::plot_grid(plotCNcore, plotCNlayer, ncol=1, align="v",rel_heights = c(0.525, 0.475), rel_widths = c(0.02, 0.98)); CN_comb

ggsave("Figure2.CN_BayesStackedPlot.jpeg", plot= CN_comb, width=80, height=160,units = "mm",dpi = 800)
